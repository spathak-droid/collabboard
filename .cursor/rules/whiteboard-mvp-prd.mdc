---
description: Collaborative Whiteboard MVP requirements and technical standards
alwaysApply: true
---

# Whiteboard MVP - Product Requirements

This project is building a collaborative whiteboard platform with **bulletproof multiplayer** as the core principle. All code must align with the Week 1 MVP requirements.

## Core Principle

A simple whiteboard with perfect real-time sync beats a feature-rich board with broken collaboration.

## Change Communication Protocol (Mandatory)

**Before making any changes, ALWAYS clarify:**

1. **What needs to be changed?** - Clearly state the specific feature, bug fix, or improvement
2. **Which page/file needs to be changed?** - Identify the exact file path(s) and component(s) affected
3. **Why is this change needed?** - Explain the reasoning, problem being solved, or requirement being met

**When implementing changes, ALWAYS explain:**

- **What was changed** - Specific modifications made to code, components, or files
- **Where it was changed** - Exact file paths and line numbers (when relevant)
- **Why it was changed** - Reasoning behind the approach, how it solves the problem, and any trade-offs considered

### Example Change Communication

```
‚úÖ GOOD Change Communication:

"What needs to be changed: Add double-click to edit functionality for sticky notes
Which page/file: components/canvas/objects/StickyNote.tsx
Why: Users need to edit sticky note text after creation (MVP requirement #2)

Implementation:
- Changed: Added onDoubleClick handler to StickyNote component (lines 45-52)
- Where: components/canvas/objects/StickyNote.tsx
- Why: Double-click is standard UX pattern for editing text. Handler toggles edit mode state and focuses textarea for immediate typing. Uses React state to manage edit mode without breaking Yjs sync (text updates still go through Yjs on blur).

Also updated: StickyNote.test.tsx to test double-click behavior
Why: TDD requirement - tests must exist alongside component changes"
```

```
‚ùå BAD Change Communication:

"Fixed the sticky note editing"
```

**This protocol ensures:**
- Clear understanding of requirements before implementation
- Transparency in decision-making
- Easier code review and maintenance
- Better documentation of changes

### Documentation Guidelines

**IMPORTANT:** Do NOT create `.md` files for improvements, optimizations, or explanations.

- ‚úÖ **DO:** Explain improvements, optimizations, and changes directly in the chat
- ‚úÖ **DO:** Use inline code comments for complex logic explanations
- ‚úÖ **DO:** Add JSDoc comments for public APIs and functions
- ‚ùå **DON'T:** Create separate `.md` documentation files for improvements
- ‚ùå **DON'T:** Create `OPTIMIZATIONS.md`, `IMPROVEMENTS.md`, or similar files

**Rationale:** Keep documentation in code (comments) and explanations in chat. Avoid creating additional markdown files that need maintenance and can become outdated.

**Exception:** Only create `.md` files if explicitly requested by the user.

## Tech Stack (Mandatory)

- **Frontend**: Next.js 14 + TypeScript + Konva.js
- **Authentication**: Firebase Auth (Email, Google, GitHub)
- **Real-time Sync**: Yjs + Hocuspocus (Railway)
- **Database**: Supabase Postgres
- **State Management**: Zustand (local UI state only)
- **API**: tRPC (type-safe)
- **Deployment**: Vercel (frontend) + Railway (WebSocket)

## MVP Hard Requirements (All Mandatory)

1. ‚úÖ Infinite canvas with pan/zoom (60fps, 10%-500% range)
2. ‚úÖ Sticky notes with editable text (200x200px, 5 colors)
3. ‚úÖ At least one shape type (Rectangle/Circle/Line)
4. ‚úÖ Create, move, resize, rotate objects
5. ‚úÖ Real-time CRDT sync (<100ms object sync, <50ms cursor sync)
6. ‚úÖ Multiplayer cursors with name labels
7. ‚úÖ Presence awareness (online users list)
8. ‚úÖ Firebase Auth (3 providers)
9. ‚úÖ Production deployment on Vercel

## Critical Implementation Rules

### Real-Time Sync

```typescript
// ‚úÖ GOOD: Use Yjs for all shared state
const yObjects = ydoc.getMap('objects');
yObjects.set(objectId, { x, y, color, text });

// ‚ùå BAD: Never use setState for shared data
setObjects([...objects, newObject]); // Will break multiplayer!
```

### Performance Requirements

**These metrics MUST be verified on every code change and deployment:**

| Metric | Target | Notes |
|--------|--------|-------|
| **Frame rate** | 60 FPS | During pan, zoom, object manipulation |
| **Object sync latency** | <100ms | Time for object changes to sync between users |
| **Cursor sync latency** | <50ms | Time for cursor position to sync between users |
| **Object capacity** | 500+ objects | Without performance drops or frame rate degradation |
| **Concurrent users** | 5+ users | Without performance degradation |

**Additional Performance Standards:**
- Page load: <3 seconds (TTI - Time to Interactive)
- Sync on drag **end only**, not during drag (prevents sync spam)
- Canvas rendering must maintain 60fps even with 500+ objects visible

**Performance Testing Checklist:**
- [ ] Frame rate stays at 60 FPS during pan/zoom operations
- [ ] Frame rate stays at 60 FPS when manipulating objects (move, resize, rotate)
- [ ] Object changes sync to other users within 100ms
- [ ] Cursor positions sync to other users within 50ms
- [ ] Canvas performs smoothly with 500+ objects on screen
- [ ] No degradation with 5+ concurrent users active
- [ ] Page loads and becomes interactive within 3 seconds

### Data Structures

```typescript
// Sticky Note
{
  id: string,
  type: 'sticky',
  x: number, y: number,
  width: 200, height: 200,
  color: string, // #FFF59D, #F48FB1, #81D4FA, #A5D6A7, #FFCC80
  text: string,
  rotation: 0,
  zIndex: number,
  createdBy: string,
  modifiedAt: number
}

// Shape
{
  id: string,
  type: 'rect' | 'circle' | 'line',
  x: number, y: number,
  width: number, height: number,
  fill: string,
  stroke: string,
  strokeWidth: 2,
  rotation: number,
  zIndex: number
}
```

### Authentication Flow

- All board routes require Firebase Auth
- WebSocket connections must verify Firebase JWT token
- Token refresh handled automatically (60-min tokens)

### Persistence

- Auto-save every 30 seconds to Supabase
- Save full Yjs document state (base64 encoded)
- Load latest snapshot on board open

## Explicitly Out of Scope (Week 1)

Do NOT implement these features:

- ‚ùå Connectors/arrows between objects
- ‚ùå Frames (grouping)
- ‚ùå Standalone text elements
- ‚ùå Copy/paste
- ‚ùå Undo/redo
- ‚ùå Templates
- ‚ùå Export (PNG/PDF/SVG)
- ‚ùå Comments
- ‚ùå Version history
- ‚ùå Mobile support

## File Organization

```
app/
  (auth)/login, signup
  (dashboard)/page.tsx
  board/[id]/page.tsx
components/
  canvas/Canvas.tsx, Canvas.test.tsx
  canvas/Toolbar.tsx, Toolbar.test.tsx
  canvas/objects/StickyNote.tsx, StickyNote.test.tsx
  canvas/objects/Rectangle.tsx, Rectangle.test.tsx
lib/
  firebase/auth.ts
  yjs/provider.ts
  hooks/useCanvas.ts, useSelection.ts, useYjs.ts
  store/canvas.ts (Zustand)
server/ (separate repo for Hocuspocus)
```

## Code Quality Standards

- TypeScript strict mode (no `any` types)
- All components must be functional (no class components)
- Use Konva.js for all canvas rendering (not raw Canvas API)
- Handle disconnects gracefully (show banner, auto-reconnect)
- Never lose data during concurrent edits (Yjs CRDT guarantees this)

## Testing (TDD - Mandatory)

**Approach:** Test-Driven Development. Write tests first, then implement.

### Frontend Component Rule

**Every new component MUST have test cases created alongside it.** No component is complete without tests.

### TDD Workflow

1. **Red**: Write a failing test that describes the expected behavior
2. **Green**: Implement the minimum code to make the test pass
3. **Refactor**: Clean up while keeping tests green

### Component Test Requirements

When creating a component:
- Create `ComponentName.test.tsx` (or `.spec.tsx`) in the same directory
- Tests must exist before or alongside the component‚Äînever ship without them
- Cover: rendering, user interactions, props, edge cases

```typescript
// ‚úÖ GOOD: StickyNote.test.tsx exists alongside StickyNote.tsx
components/canvas/objects/
  StickyNote.tsx
  StickyNote.test.tsx
  Rectangle.tsx
  Rectangle.test.tsx
```

### What to Test (Frontend)

| Component Type | Test Focus |
|----------------|------------|
| **UI Components** | Renders correctly, handles props, responds to user events |
| **Canvas Objects** | Position, selection state, color, text content |
| **Hooks** | Return values, state updates, side effects |
| **Utils** | Pure functions: input ‚Üí output |

### Example: Component Test Structure

```typescript
// StickyNote.test.tsx
import { render, screen, userEvent } from '@testing-library/react';
import { StickyNote } from './StickyNote';

describe('StickyNote', () => {
  it('renders with default color and text', () => {
    render(<StickyNote id="1" x={0} y={0} text="" color="#FFF59D" />);
    expect(screen.getByRole('group')).toBeInTheDocument();
  });

  it('enters edit mode on double-click', async () => {
    const user = userEvent.setup();
    render(<StickyNote id="1" x={0} y={0} text="Hello" color="#FFF59D" />);
    await user.dblclick(screen.getByText('Hello'));
    expect(screen.getByRole('textbox')).toBeInTheDocument();
  });

  it('calls onTextChange when text is edited', async () => {
    const onTextChange = vi.fn();
    const user = userEvent.setup();
    render(<StickyNote id="1" x={0} y={0} text="" color="#FFF59D" onTextChange={onTextChange} />);
    await user.dblclick(screen.getByRole('group'));
    await user.type(screen.getByRole('textbox'), 'New text');
    expect(onTextChange).toHaveBeenCalledWith('New text');
  });
});
```

### Test Stack

- **Unit/Component**: Vitest + React Testing Library (or Jest)
- **E2E**: Playwright (per PRD: signup ‚Üí create board ‚Üí real-time sync flow)

### Checklist Before Merging a Component

- [ ] Test file exists (`ComponentName.test.tsx`)
- [ ] Tests cover core behavior (render, props, interactions)
- [ ] All tests pass
- [ ] No skipped or `.only` tests committed

## Deployment Checklist

- [ ] Vercel: Next.js app with env variables set
- [ ] Railway: Hocuspocus server running on port 1234
- [ ] Firebase: Auth providers enabled (Email, Google, GitHub)
- [ ] Supabase: Database tables created with RLS policies
- [ ] Sentry: Error tracking configured

## Creative Freedom & Enhancements

While MVP requirements are mandatory, you're encouraged to:

### ‚úÖ Allowed Enhancements

- **Better UX**: Improved animations, transitions, visual feedback
- **Code quality**: Better abstractions, reusable hooks, cleaner architecture
- **Performance optimizations**: Memoization, virtualization, lazy loading
- **Developer experience**: Better error messages, logging, debugging tools
- **Accessibility**: Keyboard shortcuts, focus management (beyond MVP minimum)
- **Polish**: Loading states, empty states, error boundaries
- **Additional testing**: Integration tests, visual regression, expanded E2E coverage
- **Nice-to-have features** IF:
  - They don't delay MVP completion
  - They don't complicate the codebase significantly
  - They enhance the core multiplayer experience

### üö´ Still Not Allowed (Week 1)

Don't implement these even if you think they're "quick wins":
- Undo/redo (complex with CRDT)
- Copy/paste (clipboard complexity)
- Export features (PNG/PDF)
- Mobile responsive design (focus desktop first)
- Advanced permissions/roles
- Comments or chat features

### Best Practices (Beyond PRD)

```typescript
// ‚úÖ GOOD: Use proper TypeScript types
interface WhiteboardObject {
  id: string;
  type: 'sticky' | 'rect' | 'circle' | 'line';
  // ... other properties
}

// ‚úÖ GOOD: Extract reusable hooks
const useObjectManipulation = (objectId: string) => {
  const updatePosition = (x: number, y: number) => { /* ... */ };
  const updateSize = (width: number, height: number) => { /* ... */ };
  return { updatePosition, updateSize };
};

// ‚úÖ GOOD: Error boundaries for resilience
<ErrorBoundary fallback={<ErrorMessage />}>
  <Canvas />
</ErrorBoundary>

// ‚úÖ GOOD: Optimistic updates with rollback
const moveObject = async (id, x, y) => {
  // Update local state immediately
  yObjects.set(id, { ...object, x, y });
  
  // Yjs handles sync automatically
};
```

### Alternative Approaches Welcome

If you find a better way to implement something than specified in the PRD:
1. **Ensure it still meets ALL performance requirements** (60 FPS, <100ms object sync, <50ms cursor sync, 500+ objects, 5+ users)
2. **Prefer simpler over complex** (fewer dependencies, less code)
3. **Document why it's better** (performance, maintainability, etc.)
4. **Verify performance metrics** before considering the change complete
5. **Ask if unsure** about deviating from PRD specs

Examples of good alternatives:
- Using React 19 features if they improve performance
- Better state management patterns than shown in PRD
- More efficient Konva.js rendering techniques
- Improved Yjs sync strategies

## Questions to Ask Before Implementing

**First, clarify the change (see Change Communication Protocol above):**
1. What needs to be changed?
2. Which page/file needs to be changed?
3. Why is this change needed?

**Then, validate the implementation:**
4. Does this feature exist in the MVP checklist? (If no, is it a helpful enhancement?)
5. Will this break real-time sync?
6. Can 2+ users use this simultaneously without conflicts?
7. **Performance check:** Does this meet all performance targets?
   - 60 FPS during pan, zoom, object manipulation?
   - Object sync latency <100ms?
   - Cursor sync latency <50ms?
   - Works with 500+ objects without performance drops?
   - Supports 5+ concurrent users without degradation?
8. Does this enhance or distract from the core experience?
9. **If creating a component:** Are the test cases written (TDD)?

**After implementing, verify and explain:**
10. **Performance verification:** Have all performance metrics been tested and confirmed?
    - Frame rate: 60 FPS ‚úì
    - Object sync: <100ms ‚úì
    - Cursor sync: <50ms ‚úì
    - Object capacity: 500+ objects ‚úì
    - Concurrent users: 5+ users ‚úì
11. What was changed (specific modifications)?
12. Where was it changed (file paths and locations)?
13. Why was it changed (reasoning and approach)?

If unsure, refer to `/Whiteboard_MVP_PRD.md` for complete specifications.
