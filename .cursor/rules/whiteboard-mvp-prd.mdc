---
description: Collaborative Whiteboard MVP requirements and technical standards
alwaysApply: true
---

# Whiteboard MVP - Product Requirements

This project is building a collaborative whiteboard platform with **bulletproof multiplayer** as the core principle. All code must align with the Week 1 MVP requirements.

## Core Principle

A simple whiteboard with perfect real-time sync beats a feature-rich board with broken collaboration.

## Change Communication Protocol (Mandatory)

**Before making any changes, ALWAYS clarify:**

1. **What needs to be changed?** - Clearly state the specific feature, bug fix, or improvement
2. **Which page/file needs to be changed?** - Identify the exact file path(s) and component(s) affected
3. **Why is this change needed?** - Explain the reasoning, problem being solved, or requirement being met

**When implementing changes, ALWAYS explain:**

- **What was changed** - Specific modifications made to code, components, or files
- **Where it was changed** - Exact file paths and line numbers (when relevant)
- **Why it was changed** - Reasoning behind the approach, how it solves the problem, and any trade-offs considered

### Example Change Communication

```
‚úÖ GOOD Change Communication:

"What needs to be changed: Add double-click to edit functionality for sticky notes
Which page/file: components/canvas/objects/StickyNote.tsx
Why: Users need to edit sticky note text after creation (MVP requirement #2)

Implementation:
- Changed: Added onDoubleClick handler to StickyNote component (lines 45-52)
- Where: components/canvas/objects/StickyNote.tsx
- Why: Double-click is standard UX pattern for editing text. Handler toggles edit mode state and focuses textarea for immediate typing. Uses React state to manage edit mode without breaking Yjs sync (text updates still go through Yjs on blur).

Also updated: StickyNote.test.tsx to test double-click behavior
Why: TDD requirement - tests must exist alongside component changes"
```

```
‚ùå BAD Change Communication:

"Fixed the sticky note editing"
```

**This protocol ensures:**
- Clear understanding of requirements before implementation
- Transparency in decision-making
- Easier code review and maintenance
- Better documentation of changes

### Documentation Guidelines

**CRITICAL RULE - TOKEN CONSERVATION:** Do NOT create `.md` files when making changes. This wastes tokens and is unnecessary.

- ‚úÖ **DO:** Explain improvements, optimizations, and changes directly in the chat conversation
- ‚úÖ **DO:** Use inline code comments for complex logic explanations
- ‚úÖ **DO:** Add JSDoc comments for public APIs and functions
- ‚ùå **NEVER:** Create separate `.md` documentation files for improvements, changes, or explanations
- ‚ùå **NEVER:** Create `OPTIMIZATIONS.md`, `IMPROVEMENTS.md`, `CHANGES.md`, `NOTES.md`, or any similar markdown files
- ‚ùå **NEVER:** Create `.md` files to document code changes, feature implementations, or technical decisions

**Rationale:** 
- Keep documentation in code (comments) and explanations in chat
- Avoid creating additional markdown files that consume tokens unnecessarily
- Chat explanations are sufficient and more efficient
- Markdown files require maintenance and can become outdated

**ONLY Exception:** Create `.md` files ONLY if the user explicitly and directly requests a markdown file (e.g., "create a README.md" or "write this in a markdown file"). Even then, keep it concise.

**Default Behavior:** When making any changes, explain them in chat only. Do not create any `.md` files.

## Tech Stack (Mandatory)

- **Frontend**: Next.js 14 + TypeScript + Konva.js
- **Authentication**: Firebase Auth (Email, Google, GitHub)
- **Real-time Sync**: Yjs + Hocuspocus (Railway)
- **Database**: Supabase Postgres
- **State Management**: Zustand (local UI state only)
- **API**: tRPC (type-safe)
- **Deployment**: Vercel (frontend) + Railway (WebSocket)

## MVP Hard Requirements (All Mandatory)

1. ‚úÖ Infinite canvas with pan/zoom (60fps, 10%-500% range)
2. ‚úÖ Sticky notes with editable text (200x200px, 5 colors)
3. ‚úÖ At least one shape type (Rectangle/Circle/Line)
4. ‚úÖ Create, move, resize, rotate objects
5. ‚úÖ Real-time CRDT sync (<100ms object sync, <50ms cursor sync)
6. ‚úÖ Multiplayer cursors with name labels
7. ‚úÖ Presence awareness (online users list)
8. ‚úÖ Firebase Auth (3 providers)
9. ‚úÖ Production deployment on Vercel

## Critical Implementation Rules

### Real-Time Sync

```typescript
// ‚úÖ GOOD: Use Yjs for all shared state
const yObjects = ydoc.getMap('objects');
yObjects.set(objectId, { x, y, color, text });

// ‚ùå BAD: Never use setState for shared data
setObjects([...objects, newObject]); // Will break multiplayer!
```

### Performance Requirements

**These metrics MUST be verified on every code change and deployment:**

| Metric | Target | Notes |
|--------|--------|-------|
| **Frame rate** | 60 FPS | During pan, zoom, object manipulation |
| **Object sync latency** | <100ms | Time for object changes to sync between users |
| **Cursor sync latency** | <50ms | Time for cursor position to sync between users |
| **Object capacity** | 500+ objects | Without performance drops or frame rate degradation |
| **Concurrent users** | 5+ users | Without performance degradation |

**Additional Performance Standards:**
- Page load: <3 seconds (TTI - Time to Interactive)
- Sync on drag **end only**, not during drag (prevents sync spam)
- Canvas rendering must maintain 60fps even with 500+ objects visible

**Performance Testing Checklist:**
- [ ] Frame rate stays at 60 FPS during pan/zoom operations
- [ ] Frame rate stays at 60 FPS when manipulating objects (move, resize, rotate)
- [ ] Object changes sync to other users within 100ms
- [ ] Cursor positions sync to other users within 50ms
- [ ] Canvas performs smoothly with 500+ objects on screen
- [ ] No degradation with 5+ concurrent users active
- [ ] Page loads and becomes interactive within 3 seconds

### Data Structures

```typescript
// Sticky Note
{
  id: string,
  type: 'sticky',
  x: number, y: number,
  width: 200, height: 200,
  color: string, // #FFF59D, #F48FB1, #81D4FA, #A5D6A7, #FFCC80
  text: string,
  rotation: 0,
  zIndex: number,
  createdBy: string,
  modifiedAt: number
}

// Shape
{
  id: string,
  type: 'rect' | 'circle' | 'line',
  x: number, y: number,
  width: number, height: number,
  fill: string,
  stroke: string,
  strokeWidth: 2,
  rotation: number,
  zIndex: number
}
```

### Authentication Flow

- All board routes require Firebase Auth
- WebSocket connections must verify Firebase JWT token
- Token refresh handled automatically (60-min tokens)

### Persistence

- Auto-save every 30 seconds to Supabase
- Save full Yjs document state (base64 encoded)
- Load latest snapshot on board open

## Explicitly Out of Scope (Week 1)

Do NOT implement these features:

- ‚ùå Connectors/arrows between objects
- ‚ùå Frames (grouping)
- ‚ùå Standalone text elements
- ‚ùå Copy/paste
- ‚ùå Undo/redo
- ‚ùå Templates
- ‚ùå Export (PNG/PDF/SVG)
- ‚ùå Comments
- ‚ùå Version history
- ‚ùå Mobile support

## File Organization

```
app/
  (auth)/login, signup
  (dashboard)/page.tsx
  board/[id]/page.tsx
components/
  canvas/Canvas.tsx, Canvas.test.tsx
  canvas/Toolbar.tsx, Toolbar.test.tsx
  canvas/objects/StickyNote.tsx, StickyNote.test.tsx
  canvas/objects/Rectangle.tsx, Rectangle.test.tsx
lib/
  firebase/auth.ts
  yjs/provider.ts
  hooks/useCanvas.ts, useSelection.ts, useYjs.ts
  store/canvas.ts (Zustand)
server/ (separate repo for Hocuspocus)
```

## Code Quality Standards

- TypeScript strict mode (no `any` types)
- All components must be functional (no class components)
- Use Konva.js for all canvas rendering (not raw Canvas API)
- Handle disconnects gracefully (show banner, auto-reconnect)
- Never lose data during concurrent edits (Yjs CRDT guarantees this)

## Code Quality & Architecture Rules (Mandatory)

### Structure & Size

**File Size Limits:**
- A file should not exceed **700 LOC** (excluding generated code)
- If a file exceeds 700 LOC, split by feature/module
- One component per file (or one main component + small private helpers)
- Don't cram multiple big components in one file

**Function Size Limits:**
- A function should not exceed **~50‚Äì80 LOC**
- If a function grows beyond this, split into smaller functions
- A function should do one thing (single responsibility principle)
- If the function name needs "and", split it (e.g., `validateAndSave` ‚Üí `validate` + `save`)

**Nesting Limits:**
- Maximum **3 levels of nesting** in a function
- If deeper nesting is needed, use early-return or extract helper functions

```typescript
// ‚úÖ GOOD: Early return reduces nesting
function processUser(user: User | null) {
  if (!user) return null;
  if (!user.email) return null;
  return validateEmail(user.email);
}

// ‚ùå BAD: Too many nested levels
function processUser(user: User | null) {
  if (user) {
    if (user.email) {
      if (isValidEmail(user.email)) {
        return user.email;
      }
    }
  }
  return null;
}
```

### Naming & Clarity

**Names must reveal intent:**
- ‚ùå Avoid: `data`, `item`, `temp`, `foo`, `bar`, `x`, `y` (unless coordinates)
- ‚úÖ Use descriptive names: `userProfile`, `canvasObject`, `selectedTool`

**Boolean naming:**
- Must start with `is`/`has`/`can`/`should`
- ‚úÖ Examples: `isSelected`, `hasPermission`, `canEdit`, `shouldSync`

**Handler and event naming:**
- Handlers start with `handle`: `handleClick`, `handleSubmit`
- Event props start with `on`: `onClick`, `onChange`, `onSelect`
- Mutations start with `set`/`update`: `setPosition`, `updateColor`

**Abbreviations:**
- ‚ùå No abbreviations unless widely known (`id`, `url`, `ui`, `api`, `db`)
- ‚ùå Avoid: `usr`, `obj`, `cfg`, `mgr`, `util`
- ‚úÖ Use full words: `user`, `object`, `config`, `manager`, `utility`

### Types & Safety (TypeScript)

**Type Safety Rules:**
- ‚ùå **No `any`** (unless you add a comment explaining why + TODO to fix)
- ‚úÖ Use `unknown` over `any`, then narrow with type guards
- Define types at boundaries: API responses, DB objects, Yjs messages
- Prefer enums/union types for states instead of magic strings

```typescript
// ‚úÖ GOOD: Union type instead of magic string
type Tool = 'select' | 'sticky' | 'rect' | 'circle';

// ‚ùå BAD: Magic string
const tool = 'select'; // What if typo? 'selec'?

// ‚úÖ GOOD: Unknown with narrowing
function processApiResponse(data: unknown) {
  if (isValidApiResponse(data)) {
    return data.value; // Now safely typed
  }
  throw new Error('Invalid response');
}

// ‚ùå BAD: Any defeats type safety
function processApiResponse(data: any) {
  return data.value; // No type checking!
}
```

### Error Handling & Control Flow

**Error Handling Rules:**
- ‚ùå **Never swallow errors** (`catch {}` is not allowed)
- ‚úÖ Always log errors or rethrow with context
- No silent fallbacks unless intentionally designed (and documented)

**Control Flow:**
- Prefer early return over else-chains for readability
- Use guard clauses to reduce nesting

```typescript
// ‚úÖ GOOD: Early return with error handling
async function saveObject(object: CanvasObject) {
  if (!object.id) {
    throw new Error('Object must have an id');
  }
  
  try {
    await yObjects.set(object.id, object);
  } catch (error) {
    console.error('Failed to save object:', error);
    throw new Error(`Failed to save object ${object.id}`, { cause: error });
  }
}

// ‚ùå BAD: Swallowed error
async function saveObject(object: CanvasObject) {
  try {
    await yObjects.set(object.id, object);
  } catch {
    // Silent failure - user has no idea what went wrong!
  }
}
```

### State & Data Flow (Realtime/Cursors)

**Critical Rules for Multiplayer State:**

**Single Source of Truth:**
- Single source of truth for presence/cursor state
- Don't duplicate state in multiple stores
- Normalize state: use maps keyed by `userId` for cursors/presence

**Data Validation:**
- Never update UI state directly from raw network payloads
- Always validate/transform network data first
- Throttle high-frequency events (cursor movement) client-side to avoid flooding

```typescript
// ‚úÖ GOOD: Normalized cursor state
const cursors = new Map<string, CursorState>();
cursors.set(userId, { x, y, name });

// ‚ùå BAD: Duplicated state
const cursorPositions = { [userId]: { x, y } };
const cursorNames = { [userId]: name };
const cursorStates = { [userId]: { ... } }; // Duplication!

// ‚úÖ GOOD: Throttled cursor updates
const throttledUpdateCursor = throttle((x: number, y: number) => {
  yAwareness.setLocalStateField('cursor', { x, y });
}, 50); // Update max every 50ms

// ‚ùå BAD: Every mouse move floods network
onMouseMove((e) => {
  yAwareness.setLocalStateField('cursor', { x: e.x, y: e.y });
});
```

### Performance

**Render Performance:**
- No work in render that can be memoized
- Heavy computations ‚Üí use `useMemo`/selectors
- Avoid re-render storms: stable callbacks (`useCallback`), stable derived state

**Network & Updates:**
- Batch network updates when possible
- Avoid deep cloning large objects repeatedly
- Use object references when possible (Yjs handles immutability)

```typescript
// ‚úÖ GOOD: Memoized expensive computation
const visibleObjects = useMemo(() => {
  return objects.filter(obj => isInViewport(obj, viewport));
}, [objects, viewport]);

// ‚ùå BAD: Recomputes on every render
const visibleObjects = objects.filter(obj => isInViewport(obj, viewport));

// ‚úÖ GOOD: Stable callback
const handleSelect = useCallback((id: string) => {
  setSelectedId(id);
}, []);

// ‚ùå BAD: New function on every render
const handleSelect = (id: string) => {
  setSelectedId(id);
};
```

### Code Quality

**Code Cleanliness:**
- ‚ùå No commented-out code in PRs (remove it or explain why it's needed)
- ‚ùå No TODOs without an owner or issue link (or at least a clear reason)
- Every exported function/component must have a doc comment if it's non-obvious

**Testing:**
- Write the smallest test for critical logic (presence merge, conflict resolution, permissions)
- Tests must be fast and focused

```typescript
// ‚úÖ GOOD: Documented public API
/**
 * Merges cursor states from multiple users, handling conflicts.
 * @param cursors - Map of userId to cursor state
 * @returns Normalized cursor array sorted by userId
 */
export function mergeCursors(cursors: Map<string, CursorState>): CursorState[] {
  // ...
}

// ‚ùå BAD: No documentation, unclear purpose
export function mergeCursors(cursors: Map<string, CursorState>) {
  // ...
}

// ‚úÖ GOOD: TODO with context
// TODO: Optimize for 100+ concurrent users (issue #123)
function processPresence(users: User[]) {
  // ...
}

// ‚ùå BAD: Vague TODO
// TODO: fix this
```

### Architecture Boundaries

**Layer Separation:**
- UI layer cannot call network directly (go through a service/client module)
- Networking modules must be framework-agnostic (no React imports)
- Shared utils must not import app-specific modules (keep dependency direction clean)

```typescript
// ‚úÖ GOOD: Service layer abstraction
// lib/services/cursorService.ts (no React imports)
export async function updateCursor(x: number, y: number) {
  await yAwareness.setLocalStateField('cursor', { x, y });
}

// components/Cursor.tsx
import { updateCursor } from '@/lib/services/cursorService';

// ‚ùå BAD: UI directly calling network
// components/Cursor.tsx
import { yAwareness } from '@/lib/yjs/provider';
// Direct network access in UI component
```

**Dependency Direction:**
```
UI Components ‚Üí Services ‚Üí Network/DB
     ‚Üì              ‚Üì
   Utils ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ Shared Utils (no app-specific imports)
```

### Git/PR Discipline

**PR Size & Scope:**
- PRs should be **<400 lines changed** ideally (split if bigger)
- One PR = one purpose (no drive-by refactors mixed with features)
- Add screenshots/recordings for UI changes

**PR Checklist:**
- [ ] PR is <400 lines changed (or justified if larger)
- [ ] Single purpose (feature OR bugfix OR refactor, not mixed)
- [ ] Screenshots/recordings added for UI changes
- [ ] All tests pass
- [ ] No commented-out code
- [ ] No vague TODOs without context

## Testing (TDD - Mandatory)

**Approach:** Test-Driven Development. Write tests first, then implement.

### Frontend Component Rule

**Every new component MUST have test cases created alongside it.** No component is complete without tests.

### TDD Workflow

1. **Red**: Write a failing test that describes the expected behavior
2. **Green**: Implement the minimum code to make the test pass
3. **Refactor**: Clean up while keeping tests green

### Component Test Requirements

When creating a component:
- Create `ComponentName.test.tsx` (or `.spec.tsx`) in the same directory
- Tests must exist before or alongside the component‚Äînever ship without them
- Cover: rendering, user interactions, props, edge cases

```typescript
// ‚úÖ GOOD: StickyNote.test.tsx exists alongside StickyNote.tsx
components/canvas/objects/
  StickyNote.tsx
  StickyNote.test.tsx
  Rectangle.tsx
  Rectangle.test.tsx
```

### What to Test (Frontend)

| Component Type | Test Focus |
|----------------|------------|
| **UI Components** | Renders correctly, handles props, responds to user events |
| **Canvas Objects** | Position, selection state, color, text content |
| **Hooks** | Return values, state updates, side effects |
| **Utils** | Pure functions: input ‚Üí output |

### Example: Component Test Structure

```typescript
// StickyNote.test.tsx
import { render, screen, userEvent } from '@testing-library/react';
import { StickyNote } from './StickyNote';

describe('StickyNote', () => {
  it('renders with default color and text', () => {
    render(<StickyNote id="1" x={0} y={0} text="" color="#FFF59D" />);
    expect(screen.getByRole('group')).toBeInTheDocument();
  });

  it('enters edit mode on double-click', async () => {
    const user = userEvent.setup();
    render(<StickyNote id="1" x={0} y={0} text="Hello" color="#FFF59D" />);
    await user.dblclick(screen.getByText('Hello'));
    expect(screen.getByRole('textbox')).toBeInTheDocument();
  });

  it('calls onTextChange when text is edited', async () => {
    const onTextChange = vi.fn();
    const user = userEvent.setup();
    render(<StickyNote id="1" x={0} y={0} text="" color="#FFF59D" onTextChange={onTextChange} />);
    await user.dblclick(screen.getByRole('group'));
    await user.type(screen.getByRole('textbox'), 'New text');
    expect(onTextChange).toHaveBeenCalledWith('New text');
  });
});
```

### Test Stack

- **Unit/Component**: Vitest + React Testing Library (or Jest)
- **E2E**: Playwright (per PRD: signup ‚Üí create board ‚Üí real-time sync flow)

### Checklist Before Merging a Component

- [ ] Test file exists (`ComponentName.test.tsx`)
- [ ] Tests cover core behavior (render, props, interactions)
- [ ] All tests pass
- [ ] No skipped or `.only` tests committed

## Deployment Checklist

- [ ] Vercel: Next.js app with env variables set
- [ ] Railway: Hocuspocus server running on port 1234
- [ ] Firebase: Auth providers enabled (Email, Google, GitHub)
- [ ] Supabase: Database tables created with RLS policies
- [ ] Sentry: Error tracking configured

## Creative Freedom & Enhancements

While MVP requirements are mandatory, you're encouraged to:

### ‚úÖ Allowed Enhancements

- **Better UX**: Improved animations, transitions, visual feedback
- **Code quality**: Better abstractions, reusable hooks, cleaner architecture
- **Performance optimizations**: Memoization, virtualization, lazy loading
- **Developer experience**: Better error messages, logging, debugging tools
- **Accessibility**: Keyboard shortcuts, focus management (beyond MVP minimum)
- **Polish**: Loading states, empty states, error boundaries
- **Additional testing**: Integration tests, visual regression, expanded E2E coverage
- **Nice-to-have features** IF:
  - They don't delay MVP completion
  - They don't complicate the codebase significantly
  - They enhance the core multiplayer experience

### üö´ Still Not Allowed (Week 1)

Don't implement these even if you think they're "quick wins":
- Undo/redo (complex with CRDT)
- Copy/paste (clipboard complexity)
- Export features (PNG/PDF)
- Mobile responsive design (focus desktop first)
- Advanced permissions/roles
- Comments or chat features

### Best Practices (Beyond PRD)

```typescript
// ‚úÖ GOOD: Use proper TypeScript types
interface WhiteboardObject {
  id: string;
  type: 'sticky' | 'rect' | 'circle' | 'line';
  // ... other properties
}

// ‚úÖ GOOD: Extract reusable hooks
const useObjectManipulation = (objectId: string) => {
  const updatePosition = (x: number, y: number) => { /* ... */ };
  const updateSize = (width: number, height: number) => { /* ... */ };
  return { updatePosition, updateSize };
};

// ‚úÖ GOOD: Error boundaries for resilience
<ErrorBoundary fallback={<ErrorMessage />}>
  <Canvas />
</ErrorBoundary>

// ‚úÖ GOOD: Optimistic updates with rollback
const moveObject = async (id, x, y) => {
  // Update local state immediately
  yObjects.set(id, { ...object, x, y });
  
  // Yjs handles sync automatically
};
```

### Alternative Approaches Welcome

If you find a better way to implement something than specified in the PRD:
1. **Ensure it still meets ALL performance requirements** (60 FPS, <100ms object sync, <50ms cursor sync, 500+ objects, 5+ users)
2. **Prefer simpler over complex** (fewer dependencies, less code)
3. **Document why it's better** (performance, maintainability, etc.)
4. **Verify performance metrics** before considering the change complete
5. **Ask if unsure** about deviating from PRD specs

Examples of good alternatives:
- Using React 19 features if they improve performance
- Better state management patterns than shown in PRD
- More efficient Konva.js rendering techniques
- Improved Yjs sync strategies

## Questions to Ask Before Implementing

**First, clarify the change (see Change Communication Protocol above):**
1. What needs to be changed?
2. Which page/file needs to be changed?
3. Why is this change needed?

**Then, validate the implementation:**
4. Does this feature exist in the MVP checklist? (If no, is it a helpful enhancement?)
5. Will this break real-time sync?
6. Can 2+ users use this simultaneously without conflicts?
7. **Performance check:** Does this meet all performance targets?
   - 60 FPS during pan, zoom, object manipulation?
   - Object sync latency <100ms?
   - Cursor sync latency <50ms?
   - Works with 500+ objects without performance drops?
   - Supports 5+ concurrent users without degradation?
8. Does this enhance or distract from the core experience?
9. **If creating a component:** Are the test cases written (TDD)?

**After implementing, verify and explain:**
10. **Performance verification:** Have all performance metrics been tested and confirmed?
    - Frame rate: 60 FPS ‚úì
    - Object sync: <100ms ‚úì
    - Cursor sync: <50ms ‚úì
    - Object capacity: 500+ objects ‚úì
    - Concurrent users: 5+ users ‚úì
11. What was changed (specific modifications)?
12. Where was it changed (file paths and locations)?
13. Why was it changed (reasoning and approach)?

If unsure, refer to `/Whiteboard_MVP_PRD.md` for complete specifications.
